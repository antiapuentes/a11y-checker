{"name":"a11y-checker","tagline":"Web Accessibility Evaluation Library in Erlang","body":"*a11y-checker* is a Web Accessibility Evaluation library written in Erlang, that tests web pages for conformance to the [*Web Content Accessibility Guidelines 2.0*](http://www.w3.org/TR/WCAG20/) defined by the W3C, also know as *WGAC 2.0*, that define a serie of rules that web pages should follow to be considered accessible. The library provides test of conformance for the level A of the WCAG 2.0 in HTML, allowing to:\r\n\r\n  * Validate the level A of conformance for HTML.\r\n  * Individually test the success criteria related to the level A of conformance over HTML.\r\n  * Individually test a subset of the HTML techniques considered as sufficient by the WCAG 2.0 to achieve the level A of conformance.\r\n\r\nIt was designed in a way that eases the addition of new levels of conformance and technologies to test.\r\n\r\nDuring the development process, **Property-based testing** was used to verify the HTML techniques, making use of the [**PropEr**](http://proper.softlab.ntua.gr/) tool. An automated, random HTML generator was implemented during the testing phase.\r\n\r\n*a11y-checker*, its *Property-based tests* and its *automatic random HTML generator* are licensed under **GPLv3**.\r\n\r\nRequirements\r\n------------\r\n\r\n  * Erlang/OTP and *xmerl_scan* parser.\r\n  * *PropEr* for the Property-based tests ([PropEr installation instructions](https://github.com/manopapad/proper/blob/master/README.md))\r\n\r\n\r\nInstallation\r\n------------\r\n\r\n*a11y-checker* comes with an EMakefile you can use to compile the modules that compose the library by typing inside an Erlang console:\r\n\r\n    cd(\"path to the project\").\r\n    make:all().\r\n\r\nTo load the modules that compose *a11y-checker*, type inside the Erlang console:\r\n\r\n    cd(ebin).\r\n    l(wcag_2).\r\n    l(html_wcag2).\r\n    l(html_techniques).\r\n\r\nIf you are interested in trying the *Property-based tests*, also load:\r\n\r\n    l(html_prop).\r\n    l(html_gen).\r\n\r\nand the PropEr modules:\r\n\r\n    l(proper).\r\n    l(proper_gen).\r\n\r\nOnce you have done this, you will have access to the APIs defined by the different modules. You can find examples of use in the next section.\r\n\r\nUsage\r\n-----\r\n\r\n*a11y-checher* is composed by several Erlang modules, each of one providing different APIs.\r\n\r\nThose modules are:\r\n\r\n### wcag_2\r\nTest levels of conformance and individual success criteria for different technologies.\r\n\r\n#### Functions\r\n\r\n    conformance_level(LevelOfConformance, TechnologyList, Content, EntryType) -> boolean()\r\n\r\n    success_criterion(LevelOfConformance, TechnologyList, Content, EntryType) -> boolean()\r\n\r\nfunctions of the last type look like  *success_criterion_n_n_n_description*\r\nbeing the *n* the nomenclature given by the WCGA 2.0.\r\n\r\n#### Parameters\r\n\r\n  * *LevelOfConformace*, currently supported level is Level A.\r\n  * *TechnologyList*, currently sopported technology is HTML.\r\n  * *Content*, an string containing the HTML or a path to a file.\r\n  * *EntryType = {string, file}* depending on the nature of *Content*.\r\n\r\n#### Output\r\n\r\n  * *True*, if the content matches the conformance level or success criterion\r\n  * *False*, otherwise. Information of the failing HTML techniques and the failing HTML element are shown.\r\n\r\n#### Example\r\n\r\n    wcag_2:conformance_level(a, [html], \"<html><head>Ejemplo</head><body><img>imagen</img></body></html>\", string).\r\n\r\nOutput: *(success messages are omitted for brevity)*\r\n\r\n    Failing element: [{html,1},{body,2},{img,1}]\r\n    HTML H37: failed\r\n    Failing element: [{html,1},{body,2},{img,1}]\r\n    HTML H67: failed\r\n    Success Criterion 1.1.1: failed\r\n    .......\r\n    HTML H25: failed\r\n    Success Criterion 2.4.2: failed\r\n    .......\r\n    HTML H57: failed\r\n    Success Criterion 3.1.1: failed\r\n    .......\r\n    {validation_error,{error_missing_element_declaration_in_DTD,html}\r\n    HTML H88: failed\r\n    Success Criterion 4.1.1: failed\r\n    Success Criterion 4.1.2: failed\r\n    ......\r\n    Level A of Conformance: denied\r\n    false\r\n\r\nExplanation:\r\n\r\n* *Success criterion 1.1.1.* fails because the image doesn't contain a textual alternative [(H37)](http://www.w3.org/TR/WCAG-TECHS/H37.html), or a *NULL* *alt* attribute [(H63)](http://www.w3.org/TR/WCAG-TECHS/H67.html).\r\n* *Success criterion 2.4.2.* fails because the document doesn't contain a title  [(H25)](http://www.w3.org/TR/WCAG-TECHS/H25.html).\r\n* *Success criterion 3.1.1. fails because the language attribute is not set in the *html* element [(H57)](http://www.w3.org/TR/WCAG-TECHS/H57.html).\r\n* *Success criteria 4.1.1. and 4.1.2* fail because HTML is not used according to its specs, the DTD declaration is missing. [(H88)](http://www.w3.org/TR/WCAG-TECHS/H88.html).\r\n\r\n### html_wcag2\r\n\r\nTests if a certain success criterion is met by the HTML of the page, for a certain level of conformance.\r\n\r\nIts functionality is equivalent to the one provided by the *wcag_2:success_criterion* functions, because the technology currently supported is HTML.\r\n\r\n### html_tech\r\nTests if a certain HTML Technique is correctly applied by the web content.\r\n\r\n#### Functions\r\n\r\n    success_criterion_n(XmlElement) -> boolean()\r\n\r\nnamed following the nomenclature used by the WCAG 2.0 (Hnum), plus a brief description of the technique.\r\n\r\n#### Parameters\r\n\r\n  * *XmlElement*, structure representing the HTML document, obtained using the function *scan()* defined in the module is used:\r\n\r\n    scan (Html, type)\r\n\r\n  * *Html*, an string containing the HTML or a path to a file.\r\n  * *type = {string, file}* depending on the nature of *Html*.\r\n\r\n#### Output\r\n\r\n  * *True*, if the HTML applied correctly the technique\r\n  * *False* otherwise. Information of the failing HTML element is shown.\r\n\r\n#### Example\r\nTesting\r\n[H37 HTML technique] (http://www.w3.org/TR/WCAG-TECHS/H37.html):\r\n\r\n    html_tech:h37_only_well_formed_images(html_tech:scan(\"<html><head>Example</head><body><img>Image</img></body></html>\", string)).\r\n\r\nOutput:\r\n\r\n    false\r\n\r\nThe image doesn't contain a textual alternative.\r\n\r\n### *Property-based tests*\r\n\r\nThere are two modules related to the *Property-based tests*.\r\nTo try them you have to get PropEr installed.\r\n\r\n#### html_gen\r\n\r\nAutomatic and random HTML generator.\r\n\r\n##### Example\r\n\r\nGenerate random HTML:\r\n\r\n    proper_gen:pick(html_gen:html()).\r\n\r\nMore information about [*proper_gen:pick*](http://proper.softlab.ntua.gr/doc/proper_gen.html#pick-1) and [proper_gen](http://proper.softlab.ntua.gr/doc/proper_gen.html).\r\n\r\n\r\n#### html_prop\r\n\r\nDefines the properties that the HTML Techniques should follow.\r\n\r\n##### Example\r\n\r\nTest the property related to [(H37)](http://www.w3.org/TR/WCAG-TECHS/H37.html) over randomly generated HTML:\r\n\r\n    proper:quickcheck(html_prop:prop_well_formed_images()).\r\n\r\nProper looks for counterexamples (HTML code) where the property fails and provides an shrinked counterexample.\r\n\r\nMore information about PropEr [here](http://proper.softlab.ntua.gr/doc/).\r\n\r\nKnown issues\r\n============\r\n\r\n  * *a11y-checker* uses an XML parser: *xmerl_scan* to parse the HTML content. Hence, if your page is not well-formed *a11y-checher* will fail to parse the document.\r\n\r\n  * *a11y-checker* currently supports HTML, if your page contains javascript code, parsing errors can happen when parsing the document using *xmerl_scan*.\r\n\r\n  * Sometimes we have detected problems when parsing content of certain HTML attributes if it contains special characters.\r\n\r\n  * The DTD's address specified in the HTML DOCTYPE declaration must be a local file, *xmerl_scan* doesn't have support to retrieve it from the web. You can use: \"../src/html/data/DTD/xhtml1-transitional.dtd\"`\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}